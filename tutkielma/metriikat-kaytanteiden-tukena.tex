\documentclass[finnish]{../tktltiki2}

% --- Packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language ---

\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% Add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}

% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}

% --- tktltiki2 options ---

\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}

\title{Metriikat käytänteiden tukena ohjelmiston laadun \ \\arvioimisessa}
\author{Kasper Hirvikoski}
\date{\today}
\level{Kandidaatintutkielma}

\abstract
{Ohjelmistot kehittyvät elinkaarensa aikana muun muassa uusien vaatimusten, optimisaatioiden, tietoturvaparannusten ja 
virhekorjausten johdosta. Kehitysvaiheessa olevan ohjelmiston laadun varmistaminen on hankalaa. Ohjelmiston testaamisen 
ja käytännössä havaittujen virheiden välillä on usein suuri kuilu. Virheiden määrää ei yleensä pystytä laskemaan 
luotettavasti ennen kuin tuote on valmis ja julkaistu asiakkaalle. Tässä piilee kuitenkin ongelman ydin: virheiden 
korjaaminen ohjelmiston julkaisun jälkeen on erittäin kallista.

    Laadun varmistaminen ja mahdollisten ongelmakohtien havaitseminen mahdollisimman aikaisessa vaiheessa hyödyttää 
kehitystyötä. Ohjelmiston koodin tuottajana on ihminen, joten ohjelmiston laatuun kohdistuu inhimilliset tekijät. 
Kehittäjän käytänteillä on suuri laadullinen merkitys ohjelmiston kehitysvaiheissa. Ohjelmiston laatua voidaan arvioida 
mekaanisilla metriikoilla, jotka pyrkivät arvioimaan ohjelmiston komponenttien laatua sekä havaitsemaan kriittiset osat 
ohjelmistosta.

    Metriikoita on lukuisia, näistä muutamia pinnalla olevia ovat koodikirnu, verkkoanalyysi, testikattavuus ja 
mutaatiotestaus. Koodikirnulla arvioidaan ohjelmiston muutoksien vaikutusta ohjelmiston virheherkkyyteen, 
verkkoanalyysillä tutkitaan ohjelmiston komponenttien riippuvuuksien vaikutusta ohjelmiston virhealttiuteen ja 
testikattavuudella sekä mutaatiotestauksella analysoidaan ohjelmiston lähdekoodin testien tehokkuutta ja laadukkuutta.

    Metriikoiden tulokset antavat lupaavia viitteitä niiden hyödystä ohjelmiston laadun varmistamisessa. Laadun 
arvioimiseen ei ole kuitenkaan löytynyt yksittäistä ''parasta'' ratkaisua eikä metriikat sovellu yksinään laadun 
arvioimiseen. Metriikoiden välillä on havaittavissa lukuisia yhtäläisyyksiä, joten suurin hyöty niistä saadaan 
yhdessä kokonaisuutena. Laadun varmistaminen tulee kohdentaa metriikoiden paljastamiin kohteisiin ohjelmistossa.

    Vaikka metriikoita on tutkittu jo pitkään, niiden täydellistä potentiaalia ei ole vieläkään valjastettu 
käyttöön. Metriikat ovat perimmiltään vielä osittain tieteellisiä eikä niitä arvioivia kehittyneitä työkaluja ole 
helposti saatavilla. Suurin hyöty niistä saadaan vasta kun ne saadaan jokaisen kehittäjän käsiin.

    Kehittäjän käytänteillä on suuri laadullinen merkitys ohjelmiston kaikissa kehitysvaiheissa, joten 
ohjelmistotuotantomenetelmät nousevat suureen rooliin. Niiden tulee ohjata laadukasta kehitystä. Lopulta kehittäjät 
tekevät laadukkaan ohjelmiston. Ulkoinen ja sisäinen laatu lähtee siitä, että ohjelmisto suunnitellaan, toteutetaan ja 
testataan käyttäen hyväksi todettuja ohjelmointitapoja ja malleja.}

\keywords{ohjelmistotuotanto, ohjelmiston laatu, laadulliset metriikat, laadulliset prosessit ja käytänteet}

\classification
{D.2.4 [Software Engineering]: Software/Program Verification
\\D.2.8 [Software Engineering]: Metrics
\\D.2.9 [Software Engineering]: Management
\\K.6.3 [Management of Computing and Information Systems]: Software Management}

\begin{document}

% --- Front matter ---

\maketitle
\makeabstract

\tableofcontents
\newpage

% --- Main matter ---

\section{Johdanto}

Ohjelmistot kehittyvät elinkaarensa aikana muun muassa uusien vaatimusten, optimisaatioiden, tietoturvaparannusten ja 
virhekorjausten johdosta. Kehitysvaiheessa olevan ohjelmiston laadun varmistaminen on 
hankalaa~\cite{BBM96, NB05, NB07, ZN08, MNDT09}. Ohjelmiston testaamisen ja käytännössä havaittujen virheiden välillä on 
usein suuri kuilu. Virheiden määrää ei yleensä pystytä laskemaan luotettavasti ennen kuin tuote on valmis ja julkaistu 
asiakkaalle. Tässä piilee kuitenkin ongelman ydin: virheiden korjaaminen ohjelmiston julkaisun jälkeen on erittäin 
kallista.

    Ohjelmiston kehittäminen on haastavaa. Vielä haastavampaa on kehittää laadukkaasti suunniteltu ja toteutettu 
ohjelmisto. Käyttäjät havaitsevat laadun oikein toimivana tuotteena, mutta ennen kaikkea laadukas suunnittelu ja 
ohjelmointi helpottaa kehitysprosessia.  Ongelmien korjaamisen sijaan kehittäjät voivat keskittyä olennaiseen eli uusien 
toiminnallisuuksien toteuttamiseen. Virheitä on mahdotonta välttää täysin.

    Laadun varmistamista rajaa ohjelmistokehityksessä henkilöt, aika ja raha~\cite{BBM96, ZN08}. Kehittäjät kohtaavat 
usein tiukkoja määräaikoja ja rajallisia henkilöresursseja laadun takaamiseen. Johtajat käyttävät käytännössä pelkästään 
omakohtaisia kokemuksiaan resurssien tehokkaaseen jakamiseen. Heillä ei läheskään aina ole tarvittavaa kokemusta tai 
tietoa, joiden pohjalta he voivat tehdä järkeviä päätöksiä ohjelmiston laadun kannalta. Tästä johtuen päätökset tehdään 
usein johtajien odotusten mukaan ja näin ollen he joutuvat arvioimaan laatua puutteellisin tiedoin. Kriittiseksi osaksi 
muodostuu siksi kehittäjien taitojen lisäksi johtajien taidot.

    Laadun varmistaminen ja mahdollisten ongelmakohtien havaitseminen mahdollisimman aikaisessa vaiheessa hyödyttää 
kehitystyötä~\cite{BBM96, NB05}. Ohjelmiston koodin tuottajana on ihminen, joten ohjelmiston laatuun kohdistuu 
inhimilliset tekijät. Kehittäjän käytänteillä on suuri laadullinen merkitys ohjelmiston kehitysvaiheissa. Ohjelmiston 
laatua voidaan arvioida mekaanisilla metriikoilla, jotka pyrkivät arvioimaan ohjelmiston komponenttien laatua sekä 
havaitsemaan kriittiset osat ohjelmistosta.

\section{Ohjelmiston laadullinen arviointi}

ISO 9000 -standardi määrittelee ohjelmiston laadun kokonaisuutena, joka kattaa tuotteen tai palvelun piirteet, jotka 
täyttävät ohjelmistolle asetetut toiveet ja tarpeet~\cite{ISO9000}. IEEE taas määrittelee laadun arviona siitä, miten hyvin 
ohjelmisto, järjestelmä, komponentti tai prosessi täyttää sille etukäteen määritellyt vaatimukset sekä asiakkaan että 
käyttäjän asettamat tarpeet ja odotukset~\cite{IEEE1074}. Molemmat määritelmät painottavat vahvasti asiakkaan tarpeiden 
täyttämistä.

    Laadulliset kriteerit on jaettu neljään osa-alueeseen: laatumalliin, ulkoisiin, sisäisiin ja käyttölaadullisiin 
metriikoihin (quality in use metrics)~\cite{ISO25010}. Laatumalli luokittelee laadun jäsenneltynä joukkona piirteitä ja 
vaatimuksia, jonka kehyksiin organisaatio määrittelee ohjelmistoa varten laadulliset kriteerit. Ulkoiset metriikat 
vastaavat ohjelmiston toimintaa, kun taas sisäiset metriikat pohjautuvat ohjelmiston sisäisiin rakenteellisiin 
mittareihin.

    Ulkoisia metriikoita voidaan mitata muun muassa julkaisun jälkeisten virheiden määrällä. Sisäisillä metriikoilla 
ohjelmiston laatua arvioidaan koodimetriikoilla, jotka mittaavat koodin monimutkaisuutta, riippuvuuksia ja muita 
vastaavia tekijöitä. Sisäinen laatu tutkii olennaisesti koodin laatua. Käyttölaadullisuus voidaan arvioida vasta kun 
ohjelmisto on julkaistu käyttötarkoitustaan varten.

    Metriikat tarjoavat yhden tehokkaan keinon ohjelmistojen laadun arviointiin. Staattisten ja dynaamisten 
virheenpaikannustekniikoiden johdosta virheiden laatu on muuttunut~\cite{ZN08}. Virheenpaikannustekniikoilla pyritään 
analysoimaan ohjelmiston lähdekoodia ja havaitsemaan siitä silmäänpistävimmät ''kielioppivirheet''. Tämän ansiosta 
suurin osa virheraportointijärjestelmiin tallennetuista raporteista, joilla kuvataan ohjelmistossa havaitut virheet, 
johtuvat pohjimmiltaan semanttisista eli loogisista ongelmista ohjelmiston koodissa~\cite{ZN08}. Metriikoiden tulee 
ottaa tämä huomioon.

\subsection{Muutoksien laadullinen vaikutus}

Nagappan ja Ball esittävät suhteellisen koodikirnu-tekniikan järjestelmän virhetiheyden ennakoimiseen~\cite{NB05}. 
Koodikirnu (code churn) mittaa ja ilmaisee määrällisesti ohjelmiston komponentteihin kohdistuvia muutoksia tietyn 
ajanjakson aikana. Koodikirnu koostuu joukosta suhteellisia mittayksiköitä, jotka rinnastetaan muuttujiin 
kuten komponenttien kokoon tai muokkauksen ajalliseen pituuteen. Suhteelliset koodikirnu-mitat havaitsevat järjestelmän 
virhetiheyden paremmin kuin ehdottomat mitat~\cite{NB05}.

    Monimutkaisuusmetriikoilla mitataan tyypillisesti ohjelmiston virhealttiutta~\cite{ZN08}. Metriikat ovat muodostettu 
esimerkiksi komponentin koodirivien, muuttujien ja metodien lukumäärästä. Niiden perimmäinen tarkoitus on arvioida 
kuinka monimutkainen jokin ohjelmiston komponentti on. Taustalla on yksinkertainen olettamus että monimutkaisuus lisää 
ohjelmiston virheherkkyyttä~\cite{CK94, BBM96, NB05, NB07, ZN08, MNDT09}. Monimutkaisuusmetriikat keskittyvät harvoin 
komponenttien välisiin vuorovaikutussuhteisiin.

\subsection{Riippuvuuksien laadullinen vaikutus}

    Ohjelmiston komponentit riippuvat usein toisista komponenteista, jolloin ne käyttävät niiden tarjoamia palveluita 
tuottaakseen oman toiminnallisuutensa. Järjestelmän riippuvuudet voidaan esittää verkkoina, joissa komponenttien 
keskinäiset suhteet paljastuvat~\cite{ZN08}. Niistä ilmenee mitä osia komponentit tarvitsevat toiminnalleen sekä mitkä 
osat tarvitsevat komponentin palveluita.

    Zimmermann ja Nagappan esittävät verkkoanalyysin suorittamista komponenttien riippuvuusverkoille~\cite{ZN08}. 
Verkkoanalyysillä voidaan paikallistaa ohjelmiston kriittiset komponentit, jotka ovat muita virheherkempiä. Tämä 
tapahtuu tutkimalla verkkoa sekä kokonaisuutena että osina (aliverkot) erilaisten verkkometriikoiden pohjalta. 
Ohjelmistojen kohdalla komponentit muodostavat verkon toimijat ja komponenttien väliset riippuvuudet sekä niiden väliset 
vuorovaikutukset.

    Verkkometriikat pystyvät paikallistamaan ohjelmiston kannalta komponentit, joita kehittäjät pitävät tärkeinä. 
Verkkoanalyysillä saavutetaan myös parempi hyötyaste kuin pelkillä komponenttien monimutkaisuutta mittaavilla 
metriikoilla~\cite{ZN08}.

\subsection{Testauksen merkitys}

Ohjelmiston kehityksessä koodin testaaminen on kriittinen osa laadun takaamista. Testaamisessa ohjelmiston lähdekoodi 
alistetaan testitapauksille, joiden tarkoitus on kattaa ja varmistaa mahdollisimman hyvin loogiset tilanteet, jotka 
ohjelmisto käy läpi. Parhaassa tapauksessa testit löytävät virheet ohjelmistosta ja kehittäjät pystyvät korjaamaan ne 
ennen kuin tuote julkaistaan asiakkaalle. Näin ohjelmiston jatkokehitys helpottuu ja tuotteen käyttäjät säästyvät 
turhautumisilta.

    Mockus, Nagappan ja Dinh-Trong tutkivat testien laadullista arviointia keinona havaita virheherkkiä komponentteja 
ohjelmistosta~\cite{MNDT09}. Testien analysoimisessa tulee keskittyä nimenomaan niiden kykyyn havaita mahdollisia 
virheitä ohjelmistosta. Taitavat kehittäjät tuottavat laadukkaampia testejä, mutta testien tehokkuuden ja laadun 
arvioiminen tulee toteuttaa automaattisesti~\cite{MNDT09}. Yleisin testien tehokkuutta arvioiva mittari on 
testikattavuus.

    Testikattavuuden lajeja on useita. Yksinkertaisista luokka-, funktio-, metodi- ja käskykattavuuksista kehittyneisiin 
haara- ja polkukattavuuksiin. Nimensä mukaan kukin laji testaa lähdekoodin eri osa-alueita. Funktio- ja 
metodikattavuu\-della kartoitetaan testien kattavuutta yhden toiminnallisuuden osalta, luokkakattavuudella taas näistä 
muodostuvan kokonaisuuden testien kattavuutta. Taustalla on olettamus, että jos jokin yksittäinen looginen ehto tai 
polku ei ole katettu vähintään yhdellä testillä, ei sen mahdollisesti sisältämiä virheitä pystytä 
havaitsemaan~\cite{MNDT09}.

    Voidaan olettaa, että suurempi testikattavuus löytää todennäköisesti enemmän virheitä ja takaa paremman laadun. 
Kattavuus kuvaa yksinkertaisesti osuutta siitä kuinka monta riviä ohjelmakoodia on katettu sitä testaavalla 
testikoodilla. Kattavuudella ei kuitenkaan pystytä arvioimaan kuinka todennäköisesti nämä rivit aiheuttavat virheen, 
siksi suuri testikattavuus ei yksinään takaa laatua. Testikattavuus saattaa vääristyä helposti testeillä, jotka eivät 
todellisuudessa tarkista ohjelmiston koodin varsinaista toimintaa. Tästä huolimatta testikattavuus auttaa merkittävästi 
laadun varmistamisessa. Muita metriikoita tulee käyttää kohdentamaan testejä ohjelmiston kriittisiin 
osa-alueisiin~\cite{NB07, MNDT09, YH11}.

    Testien laadun arvioimiseen on ehdotettu mutaatiotestausta~\cite{YH11}. Mutaatiotestaus arvioi testien sopivuutta 
niiden kattamaan lähdekoodiin simuloimalla yleisempiä virheitä joita kehittäjät tekevät. Alkuperäisen ohjelmiston 
lähdekoodin syntaksia muuttamalla se tutkii testien laatua ja tehokkuutta havaita mahdollisia virheitä ohjelmiston 
lähdekoodissa. Yksinkertaisten syntaksimuutosten avulla mutaatiotestaus pystyy muodostamaan virheellisiä 
mutanttiversioita ohjelmistosta, joiden ei kuulu mennä testeistä läpi.

\subsection{Koodin kehittäjänä ihminen}

Laadun takeeksi ei voida luetella pelkästään mekaanisia laatua arvioivia metriikoita. Kehittäjän käytänteillä on suuri 
laadullinen merkitys ohjelmiston kaikissa kehitysvaiheissa, joten ohjelmistotuotantomenetelmät nousevat suureen rooliin. 
Niiden tulee ohjata laadukasta kehitystä.

    Ennakkosuunniteluun pohjautuvien tuotantomenetelmien, kuten vesiputousmallin, rinnalle on noussut uusia ketterän 
kehityksen prosesseja. Ne painottavat yksilöitä ja yksilöiden vuorovaikutusta, toimivan ohjelmiston merkitystä, 
asiakkaan merkitystä kehitysprosessin kriittisenä osana ja muutoksiin sopeutuvaa kehitystä~\cite{BBB01}. Ketterässä 
kehityksessä ohjelmisto tuotetaan iteratiivisesti, pala kerrallaan, sopeutuen uusiin tavoitteisiin. Vesiputousmallissa, 
jossa ohjelmisto suunnitellaan tiukasti ennen toteutusta, lopputuotokset eivät yleensä vastaa haluttua tulosta, 
varsinkaan asiakkaan kannalta. Useat empiiriset tutkimukset tukevat ketterien kehitysprosessien hyötyä merkittävänä 
laadullisina vaikuttajana~\cite{SS10}.

\section{Metriikat}

Metriikat tarjoavat yhden tehokkaan keinon ohjelmistojen laadun arviointiin. Metriikoita on lukuisia, näistä muutamia 
pinnalla olevia ovat koodikirnu, verkkoanalyysi, testikattavuus ja mutaatiotestaus. Koodikirnulla arvioidaan ohjelmiston 
muutoksien vaikutusta ohjelmiston virheherkkyyteen, verkkoanalyysillä tutkitaan ohjelmiston komponenttien riippuvuuksien 
vaikutusta ohjelmiston virhealttiuteen ja testikattavuudella sekä mutaatiotestauksella analysoidaan ohjelmiston 
lähdekoodin testien tehokkuutta ja laadukkuutta.

\subsection{Perinteiset metriikat}

Metriikoiden käyttäminen ohjelmiston virheherkkyyden ja laadun arvioimisessa ei ole uusi käytäntö. Metriikoita on 
ehdotettu ja tutkittu vuosikymmenien ajan. Perinteisimmät mittarit pohjautuvat ohjelmiston lähdekoodin koodirivien 
määrään~\cite{BBM96}. Olio-ohjelmoinnin noustessa vahvempaan suosioon 90-luvulla, ryhtyivät tutkijat pohtimaan mittoja 
jotka soveltuisivat kyseiseen ajatusmalliin.

    Vuonna 1994 Chidamber ja Kemerer ehdottivat kuusi olio-ohjelmointimit\-taria ohjelmiston laadun 
arvioimiseen~\cite{CK94}. Nämä CK-metriikat keskittyvät metodien, yliluokkien, ja lapsien lukumääriin sekä tutkivat 
komponenttien riippuvuuksia, vastuita ja yhtenäisyyttä. Metodien määrällä kuvataan muun muassa komponentin 
monimutkaisuutta. Valtaosa kyseisistä mitoista on havaittu tehokkaiksi ja käytännöllisiksi arvioiksi ohjelmiston 
komponenttien virhealttiuden mittaamisessa~\cite{BBM96}.

    Ajatuksena on, että mitä enemmän luokalla on metodeja sen monimutkaisempi se on~\cite{BBM96}. Luokalla, jolla on 
suuri määrä yliluokkia lisää riskiä, että jokin näistä yliluokista aiheuttaa ongelmia kyseiselle luokalle. Vastaavasti 
luokka, jolla on paljon lapsia, vaikeuttaa luokalle tehtäviä muutoksia niin, että aliluokkien toiminnallisuus säilyy 
ehjänä. Sen lisäksi tiukat kytkökset luokkien välillä ja luokan suurempi vastuu lisäävät komponenttien virhealttiutta.

    CK-metriikat muodostavat pohjan lukuisille metriikoilla. Luokkien riippuvuudet ovat keskeisessä asemassa muun muassa 
koodikirnussa ja verkkoanalyysissä~\cite{NB05, NB07, ZN08}. Muutokset ohjelmiston lähdekoodiin laajenevat yleensä 
komponenttien riippuvuuksia pitkin~\cite{NB05, NB07}. Muutoksien edellytyksenä on usein, että myös muita komponentteja 
joudutaan muokkaamaan.

\subsection{Koodikirnu}

Koodikirnu mittaa ohjelmiston komponenttien ohjelmakoodiin kohdistuvien muutosten määrää tietyn ajanjakson 
aikana~\cite{NB05}. Muutosten määrä on esimerkiksi saatavilla ohjelmiston versionhallintajärjestelmien 
muutoshistoriasta.

    Useimmat versionhallintajärjestelmät vertailevat lähdekooditiedos\-tojen historiaa ja laskevat automaattisesti 
koodiin kohdistuvia muutoksia. Nämä muutokset ilmentävät kuinka monta riviä tiedostoon on ohjelmoijan toimesta lisätty, 
poistettu tai muutettu edelliseen versioon nähden. Nämä tiedot muodostavat koodikirnun pohjan.

    Koodikirnu koostuu joukosta suhteellisia mittoja, joilla arvioidaan komponenttien virhetiheyttä~\cite{NB05}. Näitä 
mittoja on muun muassa yhteenlaskettujen koodirivien määrä, tiedostojen muutokset ja tiedostojen määrä.

    Ohjelmistoa kehitettäessä sen komponenttien monimutkaisuus muuttuu. Monimutkaisuuden kasvun suhde on hyvä mittari 
virheherkkyyden kasvulle. Koodikirnu-mittojen on havaittu korreloivan ohjelmistoista tehtyjen vikailmoitusten 
kanssa~\cite{NB05}.

\subsubsection{Ohjelmiston virheherkkyyteen vaikuttavat koodikirnumitat}

Koodikirnu koostuu seitsemästä ehdottomasta mitasta, jotka muodostavat sille pohjan~\cite{NB05}. Ehdottomat mitat 
muodostavat suhteellisille mitoille vertailukohdat ohjelmiston virheherkkyyden analysoimisessa.

\begin{description}
    
    \item[Yhteenlaskettu koodirivien määrä,] ohjelman uuden version koodirivien summa kaikkien lähdekooditiedostojen 
                                             kesken.
    
    \item[Käsiteltyjen koodirivien määrä,] ohjelman lähdekoodiin lisättyjen ja muuttuneiden koodirivien summa 
                                           edelliseen versioon nähden.
    
    \item[Poistettujen koodirivien määrä,] ohjelman lähdekoodista poistettujen koodirivien määrä edelliseen versioon 
                                           nähden.
    
    \item[Tiedostojen määrä,] yhden ohjelman kääntämiseen tarvittavien lähdekoodi\-tiedostojen määrä.
    
    \item[Muutosten ajanjakso,] yhteen tiedostoon kohdistuneiden muutosten ajanjakson pituus.
    
    \item[Muutosten määrä,] ohjelman tiedostoihin kohdistuneiden muutosten määrä edelliseen versioon nähden.
    
    \item[Käsiteltyjen tiedostojen määrä,] ohjelman käsiteltyjen tiedostojen yhteenlaskettu määrä.

\end{description}

    Ehdottomien mittojen pohjalta muodostuu kahdeksan suhteellista koodikirnu-mittaa joiden on osoitettu korreloivan 
kohonneeseen virhemäärään koodirivejä kohden. Analyyseissä on havaittu suhteellisten mittojen ylivertaisuus ehdottomiin 
verrattuna todellisen virhetiheyden ennakoimisessa~\cite{NB05}.

\begin{enumerate}
    
    \item {\bf Käsiteltyjen koodirivien määrä / Yhteenlaskettu koodirivien määrä}
    
    Suurempi osa käsiteltyjä koodirivejä suhteessa yhteenlaskettuun koodirivien määrän vaikuttaa yksittäisen ohjelman 
    virhetiheyteen.
    
    \item {\bf Poistettujen koodirivien määrä / Yhteenlaskettu koodirivien määrä}
    
    Suurempi osa poistettuja koodirivejä suhteessa yhteenlaskettuun koodirivien määrään vaikuttaa yksittäisen ohjelman 
    virhetiheyteen.
    
    \item {\bf Käsiteltyjen tiedostojen määrä / Tiedostojen määrä}
    
    Suurempi osa käsiteltyjä tiedostoja suhteessa ohjelman rakentavien tiedostojen lukumäärään lisää todennäköisyyttä, 
    että nämä käsitellyt tiedostot aiheuttavat uusia vikoja.
    
    \item {\bf Muutosten määrä / Käsiteltyjen tiedostojen määrä}
    
    Mitä suurempi osa muutoksista on kohdistunut yksittäisiin tiedostoihin, sitä suurempi on todennäköisyys sille, että 
    tämä vaikuttaa kyseisistä lähdekooditiedostoista muodostuvan komponentin virhetiheyteen.

    \item {\bf Muutosten ajanjakso / Tiedostojen määrä}
    
    Tehtyjen muutoksien pitkä ajanjakso lisää todennäköisyyttä, että nämä tiedostot sisältävät monimutkaisia rakenteita. 
    Varsinkin jos muutokset ovat kohdistuneet pieneen joukkoon tiedostoja. Monimutkaisuus vaikuttaa koodin helppoon 
    ylläpidettävyyteen ja lisää näiden tiedostojen aiheuttamaa virhetiheyttä.

    \item {\bf Käsiteltyjen ja poistettujen koodirivien määrä / Muutosten ajanjakso}
    
    Käsiteltyjen ja poistettujen koodirivien määrä suhteessa muutosten ajanjaksoon mittaa muutoksen määrää, jota pelkkä 
    muutosten ajanjakso ei yksinään ilmaise. Oletuksena on, että mitä suurempi määrä käsiteltyjä ja poistettuja 
    koodirivejä on, sitä pitempi muutosten ajanjakson tulee olla. Tämä taas vaikuttaa ohjelman virhetiheyteen.

    \item {\bf Käsiteltyjen koodirivien määrä / Poistettujen koodirivien\\määrä}
    
    Ohjelmiston kehitys ei koostu pelkästään vikojen korjaamisesta vaan jatkuvasta uuden kehittämisestä. Uusien 
    ominaisuuksien kehittämisessä käsiteltyjen koodirivien määrä on suhteessa suurempi kuin poistettujen koodirivien 
    määrä. Suuri arvo tälle mitalle ilmaisee uutta kehitystä.

    \item {\bf Käsiteltyjen ja poistettujen koodirivien määrä / Muutosten määrä}
    
    Mitä suurempi muutoksen laajuus on suhteessa muutosten määrään, sitä suurempi virhetiheys on. Tämä mitta kompensoi 
    sitä tietoa, että yksittäisiä tiedostoja ei käsitellä toistuvasti pienten korjausten takia. Suurempi osuus 
    käsiteltyjä ja poistettuja koodirivejä käsittelyä kohden ennakoi sitä, että muutoksiin vaaditaan pitempi 
    ajanjakso. Muutoksia kohdistuu esimerkiksi jokaista viikkoa kohden sitä enemmän. Muussa tapauksessa suuri määrä 
    muutoksia on saattanut kohdistua lyhyeen ajanjaksoon, joka ennakoi suurempaa virhetiheyttä.

\end{enumerate}

\subsubsection{Johtopäätökset koodikirnusta}

Koodi joka muuttuu useasti ennen julkaisua on virheherkempää kuin koodi, joka muuttuu vähemmän saman ajanjakson 
aikana~\cite{NB05}. Tutkimukset ovat osoittaneet, että ehdottomat mittayksiköt, kuten pelkkä koodirivien summa, ovat 
huonoja ohjelmiston laadullisia ennusteita~\cite{NB05}. Yleisesti ottaen ohjelmiston kehitysprosessia mittaavien 
yksiköiden on havaittu olevan parempia osoittimia vikojen määrästä kuin pelkkää koodia arvioivat kriteerit.

    Mittojen välillä on havaittavissa lisäksi keskinäisiä suhteita, joita voidaan mallintaa verkkoina. Yksinään kyseiset 
mitat eivät välttämättä tuota toivottua tulosta. Siksi mittoja verrataan keskenään mahdollisten ristiriitaisuuksien 
havaitsemiseksi.\newline

\noindent Koodikirnusta on tehtävissä neljä johtopäätöstä:

\begin{enumerate}

    \item Suhteellisten koodikirnu-mittojen nousua seuraa ohjelmiston virheherkkyyden kasvu.

    \item Suhteelliset mitat ovat parempia laadullisia arvioijia kuin ehdottomat mitat.

    \item Suhteellinen koodikirnu on tehokas tapa arvioida ohjelmiston virheherkkyyttä.

    \item Suhteellinen koodikirnu pystyy havaitsemaan virheherkän ja toimivan komponentin toisistaan.

\end{enumerate}

\subsubsection{Koodikirnun pätevyyteen vaikuttavia tekijöitä}

Mittausvirheet vaikuttavat luotettavan arvion luomiseen~\cite{NB05}. Ongelma ei ole suuri, sillä 
versionhallintajärjestelmät hoitavat automaattisesti analyysiin vaadittavat lähtöarvot. Koodikirnu vaatii ohjelmiston 
kehittäjältä hyviä käytäntöjä. Jos kehittäjä on tehnyt useita muutoksia rekisteröimättä niitä 
versionhallintajärjestelmän historiaan, osa muutoksista jää näkemättä. Kehittäjän toimista riippuen muutosten ajanjakson 
pituus voi merkittävästi pidentyä, jos muutoksia ei hyväksytä tarpeeksi aikaisin versionhallintajärjestelmään. Mittojen 
vertaaminen keskenään lieventää tästä johtuvia poikkeamia.

    Nagappanin ja Ballin empiirisen tapaustutkimuksen pätevyyteen voidaan nähdä vaikuttavan se, että tutkimuksessa 
analysoitiin vain yhtä ohjelmistojärjestelmää~\cite{NB05}. Siitä huolimatta kyseinen ohjelmistojärjestelmä koostuu 
lukuisista komponenteista ja suuresta määrästä koodia. Analyysi on itsessään erittäin kattava.

\subsection{Verkkoanalyysi}

Ohjelmiston komponentit riippuvat usein toisista komponenteista. Järjes\-telmän riippuvuudet voidaan esittää matalan 
tason verkkoina, jossa komponenttien keskinäiset suhteet paljastuvat. Näille riippuvuusverkoille voidaan suorittaa 
verkkoanalyysi ohjelmiston virheherkkyyden arvioimiseksi~\cite{ZN08}. Verkkoanalyysillä voidaan paikallistaa ohjelmiston 
komponentit, jotka ovat oletettavasti muita virheherkempiä.

    Verkkoanalyysillä on tutkittu julkaisun jälkeisten virheilmoitusten ja riippuvuusverkkojen suhdetta. Keskeisessä 
roolissa olevat komponentit ja yksittäiset komponentit, joilla on suuri määrä keskinäisiä riippuvuuksia, ovat 
yleisesti herkempiä virheille~\cite{ZN08}.

    Riippuvuus ohjelmistoissa on suunnattu yhteys kahden koodiosan kuten lausekkeen tai metodin välillä. Riippuvuudet 
voidaan erotella toisistaan: tietoriippuvuus on määrittelyiden ja arvojen välinen yhteys. Kutsuriippuvuus on funktio- ja 
metodimäärittelyiden ja niitä kutsuvien paikkojen välinen yhteys.

    Verkoista on löydettävissä useita piirteitä, joilla keskeisessä roolissa olevat komponentit voidaan havaita 
samankaltaisista aliverkoista~\cite{ZN08}. Yksi on niin kutsuttu tähtipiirre, joka on komponenteilla joilla on useita 
satelliittikomponentteja. Satelliitit ympäröivät tähteään ja riippuvat yksinään siitä. Suurimmassa osassa tämän piirteen 
omaavista aliverkoista tähtikomponentti oli virheherkkä kun satelliitit eivät. Verkkoanalyysin mukaan tähtikomponentti 
on keskeinen komponentti, jos se ohjaa satelliittejaan. Tämänkaltaista tähtikomponenttia kutsutaan usein välittäjäksi.

    Mitä suurempi joukko verkossa olevia komponentteja riippuu keskenään toisistaan (clique), sitä suurempi on näiden 
komponenttien todennäköinen virheherkkyys. Riippuvuuden suunnalla ei tässä tapauksessa ole väliä. Joukkoa kutsutaan 
maksimaaliseksi, jos yhtään komponenttia ei voida lisätä tähän aliverkkoon siten, että maksimaalisuus ei säily.

    Virheilmoituksia vertaamalla on havaittu, että mitä enemmän riippuvuuksia maksimaalisessa joukossa on, sitä enemmän 
virheilmoituksia korreloi näihin komponentteihin~\cite{ZN08}. Yksi syy on, että nämä joukot ovat tämän tiedon valossa 
muita monimutkaisempia riippuvuuksiensa johdosta.

    Aikaisempien tutkimusten mukaan on havaittu, että koodikirnu ja riippuvuusverkot ovat yhdessä hyviä metriikoita 
ohjelmiston virheherkkyyden arvioimisessa~\cite{NB07}. Jos yksittäinen komponentti muuttuu paljon eri versioiden 
välillä, voidaan olettaa, että jonkun toisen komponentin täytyy muuttua, jotta muutokset ovat mahdollisia. Muutos 
yleensä leviää riippuvuuksien välillä.

    Riippuvuusverkossa näkyvät yhteydet ilmentävät kuinka paljon työtä tarvitaan yhteyksien ylläpitämiseen. Muutosten 
määrän lisäksi yhteydet voivat kertoa virheherkkyydestä muutakin tärkeää tietoa. Lähdekoodi ei muodostu pelkästään 
yksittäisistä komponenteista vaan arkkitehtuurista josta koko ohjelmisto rakentuu. Näitä arvioimalla pystytään 
paikallistamaan muita virheherkempiä komponentteja ja kohdistamaan resurssit testejä ja koodikatselmusta varten.

\subsubsection{Ohjelmiston virheherkkyyteen vaikuttavat verkkomitat}

    Seuraavien neljän verkkomitan on havaittu korreloivan positiivisesti tai merkittävästi julkaisun jälkeen 
ilmoitettuihin virheisiin~\cite{ZN08}.

\begin{enumerate}
    
    \item {\bf Egoverkot}
    
    Jokaisella solmulla, eli komponentilla, on verkossa sitä vastaava egoverkko, joka kuvaa miten kyseinen solmu on 
    kytketty naapurisolmuihinsa. Komponentteja, jotka riippuvat solmusta kutsutaan sisäsolmuiksi, ja komponentteja 
    joista solmu itse riippuu kutsutaan ulkosolmuiksi. Egoverkko on sisä- ja ulkosolmujen muodostama aliverkko. Se 
    mahdollistaa komponentin paikallisen tärkeyden mittaamista suhteessa naapureihinsa.
    
    Egoverkolle voidaan suorittaa useita mittauksia. Tehokkaimpia metriikoita ovat mukaan mittarit, jotka kohdistuvat 
    muun muassa egoverkon kokoon, komponenttien siteisiin, pareihin ja tiheyteen sekä verkon eli riippuvuuksien 
    polkuihin. Ulkosolmut, joista muut komponentit riippuvat, ovat sisäsolmuja virheherkempiä~\cite{ZN08}.
        
    \item {\bf Globaaliverkot}
    
    Globaaliverkko muodostuu koko ohjelmiston riippuvuusverkosta ja sen muodostavien komponenttien välisistä 
    riippuvuuksista. Globaaliverkosta voidaan tutkia yksittäisen solmun tärkeyttä koko ohjelmiston kannalta ja näin 
    havaita koko ohjelmiston kriittisimmät komponentit. Keskeisessä roolissa olevat komponentit muita 
    virheherkempiä~\cite{ZN08}.
    
    \item {\bf Rakenteelliset puutteet}
    
    Ideaalisesti solmujen väliset riippuvuudet ovat toisiinsa nähden tasapainossa. Jos kaikilla komponenteilla on 
    keskinäinen suhde toisiinsa, vallitsee solmujen välillä tasapaino. Jos joidenkin solmujen välillä ei ole keskinäistä 
    riippuvuutta, vaan ne riippuvat toisistaan jonkun toisen solmun kautta, ohjaavalla solmulla on selvä etulyöntiasema. 
    Välittäjäsolmut ovat muita virheherkempiä~\cite{ZN08}.
    
    \item {\bf Keskeisyys}
    
    Yleisin verkkomitoista on solmun keskeisyys. Sillä pyritään havaitsemaan komponentit jotka ovat suotuisassa 
    asemassa, eli useat muut komponentit riippuvat kyseisestä komponentista. Keskeisyyttä voidaan mitata riippuvuuksien 
    määrällä, komponenttien riippuvuuksien etäisyyksillä toisistaan ja komponentista johtavien riippuvuuspolkujen 
    piirteillä. Mikäli komponentti riippuu suuresta määrästä toisia komponentteja, on se todennäköisesti muita 
    komponentteja virheherkempi.
    
    Komponentit, joiden riippuvuuksien välillä on lyhyet polut, voidaan todeta olevan muita virhealttiimpia. Muutokset 
    näihin komponentteihin yleensä leviävät komponenttien riippuvuuksiin~\cite{ZN08}.
    
    Keskeisyydellä on myös vastakkainen vaikutus. Keskeisyys saattaa tehdä komponenteista vähemmän 
    virheherkkiä~\cite{ZN08}. Oletettavasti näihin komponentteihin on kehitystyössä panostettu enemmän, joka parantaa 
    niiden laatua.
    
\end{enumerate}

\subsubsection{Johtopäätökset verkkoanalyysistä}

Verkkoanalyysin havaitsemia komponentteja on verrattu kehittäjien näkemyksiin kriittisistä komponenteista~\cite{ZN08}. 
Verkkoanalyysillä löydettiin kaksi kertaa enemmän kriittisiä komponentteja kuin pelkillä monimutkaisuusmetriikoilla.

    Yksittäisissä tapauksissa monimutkaisuusmetriikat olivat toisaalta hieman parempia kuin verkkometriikat. 
Olio-ohjelmointiin liittyvät monimutkaisuusmetriikat eivät kuitenkaan sovellu epäyhtenäisten ohjelmistojen arvioimiseen. 
Ohjelmiston täytyy noudattaa täysin olio-paradigmaa, jotta metriikoilla on merkitystä.\newline

\noindent Verkkoanalyysistä on tehtävissä neljä johtopäätöstä:

\begin{enumerate}

    \item Verkkometriikat riippuvuusverkoissa pystyvät löytämään kriittisiä komponentteja, joita pelkät 
          monimutkaisuusmetriikat eivät havaitse.
          
    \item Verkkometriikoiden antamat arvot riippuvuusverkoissa korreloivat julkaisun jälkeen ilmoitettujen virheiden 
          kanssa. Suurempaa arvoa johtaa todennäköisesti suurempi virhetiheys.
          
    \item Verkkometriikat riippuverkoissa pystyvät arvioimaan julkaisun jälkeisten virheiden määrää.

\end{enumerate}

\subsubsection{Verkkoanalyysin pätevyyteen vaikuttavia tekijöitä}

Zimmermann ja Nagappan olettivat tutkimuksessaan, että virheet ja niiden korjaukset sijoittuvat lähdekoodissa samaan 
paikkaan~\cite{ZN08}. He toteavat, että näin ei aina ole, mutta tämä olettamus on yleisesti käytössä tutkimuksissa.

    Yleisesti pätevien päätelmien tekeminen empiirisistä tutkimuksista on vaikeaa niiden kontekstisidonnaisen luonteen 
takia. Virheherkkyyden arvioimiseen ei ole löytynyt yksittäistä ''parasta'' ratkaisua, joten verkkoanalyysin tuottamia 
tuloksia ei pystytty vertailemaan sellaisen tehokkuuteen. Tulokset antavat lupaavia viitteitä.

   Zimmermannin ja Nagappanin tapaustutkimukseen voi vaikuttaa se, että tutkimuksessa analysoitiin vain yhtä 
ohjelmistojärjestelmää. Tämä järjestelmä on kuitenkin kooltaan suurempi kuin useat muut kaupalliset ohjelmistot. Tästä 
johtuen verkkoanalyysin soveltuu todennäköisesti virheherkkyyden arvioimiseen muissa ohjelmistoissa. 

    Verkkoanalyysi ei sovellu yksinään virheherkkyyden arvioimiseen. Sen voidaan nähdä olevan osa palapeliä. 
Tutkimuksissa esille tulleet monimutkaisuusmetriikat ja koodikirnu ovat varteenotettavia lisiä verkkoanalyysin 
tehokkuudelle~\cite{ZN08}. Mikään kyseisistä metriikoista ei kuitenkaan ota huomioon virheiden inhimillistä tekijää. 
Kehittäjät loppujen lopuksi aiheuttavat virheet itse kehitystyön tuloksena.

\subsection{Testikattavuus}

Testien arvioimisessa tulee nimenomaan keskittyä testien kykyyn havaita mahdollisia virheitä 
ohjelmistosta~\cite{MNDT09}. Parempien testien tulee löytää enemmän mahdollisia ongelmakohtia ohjelmiston lähdekoodista 
ja näin johtaa ohjelmiston parempaa laatuun.

    Tutkimuksissa on havaittu, että suurempaa testikattavuutta seuraa pienempi määrä julkaisun jälkeisiä 
virheilmoituksia~\cite{MNDT09}. Suuremman testikattavuuden saavuttaminen kasvaa eksponentiaalisesti, mitä suurempiin 
testikattavuuksiin tähdätään. Samalla virheherkkyys vähenee vain lineaarisesti. Optimaalinen testikattavuus ei tunnu 
olevan lähelläkään 100 \%, eikä sen saavuttaminen ole ohjelmiston laadun kannalta välttämätöntä, saati tehokasta.

    Testikattavuuden kannalta on mielenkiintoista tietää kuinka suuri osa itse testeistä havaitsi virheet. Suurin osa 
tästä työstä tapahtuu kehittäjän toimesta kehitysvaiheessa yksikkötestauksen tasolla. Viitteet tästä eivät tallennu 
versionhallintaan eikä virheitä ilmoiteta virheraportointijärjestelmiin. Tämän korrelaation tutkiminen on valitettavan 
haasteellista.

    Lähdekoodin monimutkaisuus, ohjelmiston käyttökohde, kehittäjien kokemus ja etätyöskentely vaikuttavat ohjelmiston 
virheherkkyyteen sekä testien kattavuuteen~\cite{MNDT09}. Vähemmän kokeneilla kehittäjillä ja etätyöskentelyssä 
testikattavuuden merkitys kasvaa merkittävästi. 

\subsubsection{Testikattavuuden vaikutus ohjelmiston virheherkkyyteen}

Versionhallinta- ja virheraportointijärjestelmistä sekä testikattavuudesta saatavia tietoja on analysoitu ohjelmiston 
virheherkkyyteen vaikuttavien taustatekijöiden löytämiseksi~\cite{MNDT09}. Samalla ohjelmistoista on laskettu 
monimutkaisuusmetriikoita ja tutkittu lähdekoodin muutosten määrää. Aikaisempien tutkimusten mukaan muutosten määrä on 
varteenotettava mittari virheherkkyyden arvioimiseen, siksi testikattavuus on syytä suhteuttaa siihen.

    Testikattavuuden kasvulla ja julkaisun jälkeisten virheilmoitusten vähenemisellä on havaittu selvä 
korrelaatio~\cite{MNDT09}. Lähdekooditiedostoista joita testit eivät kata löytyy eniten virheilmoituksia. Vastaavasti 
tiedostoille, joiden testikattavuus oli vähintään puolet, virheiden määrä oli pienempi. Testikattavuuden teho ryhtyy 
vähenemään jo 50 \% testikattavuuden jälkeen.

    Versionhallintajärjestelmistä pystytään analysoimaan testikattavuuden saavuttamiseen käytetty aika, eli kuinka kauan 
kehittäjän on täytynyt käyttää yksittäisen komponentin automaattiseen testaamiseen. Kattavimpiin testeihin kuluu 
eksponentiaalisesti pidempi aika mitä korkeampia testikattavuuksia tavoitellaan. Tämä viittaa siihen, että täyden 
testikattavuuden tavoittaminen ei kaikissa tapauksista ole välttämättä hyödyllistä~\cite{MNDT09}. Tämä voi johtua siitä, 
että tiedostot jotka muuttuvat eniten ovat testattu kattavammin, sillä muutokset tuovat helposti uusia virheitä. 50 \% 
testikattavuuden saavuttaminen näyttää tulosten pohjalta olevan suhteellisen helppoa.

    Kehittäjät, jotka kirjoittavat lähdekoodin alusta asti, testaavat yleensä koodin kattavammin. Kehittäjät, jotka vain 
ylläpitävät toisten kirjoittamaa koodia, harvoin kasvattavat koodin testikattavuutta. Loogisesti monimutkaiset 
ja helpot lähdekooditiedostot testataan usein muita tarkemmin. Komponentit, jotka tarjoavat palveluita useille muille 
komponenteille testataan myös huolellisesti tutkimusten mukaan~\cite{MNDT09}.

    Keskeisessä roolissa olevista komponenteista saatetaan toisaalta löytää enemmän virheitä puhtaasti sen takia, että 
niitä käytetään~\cite{MNDT09}. Nämä komponentit joutuvat tiukempiin käytännöntilanteisiin liittyviin testauksiin. 
Testikattavuuden saavuttaminen on heikompaa käyttöliittymään ja tietokantaan liittyvissä koodiosuuksissa, koska näiden 
testaamista pidetään kehittäjien keskuudessa muita haastavampana. Etätyöskentely tuntuu vähentävän testauksen määrää 
vaikka nimenomaan etätyöskentelyssä testaus nousee tärkeään rooliin.

\subsubsection{Johtopäätökset testikattavuudesta}

Testikattavuuden lähtökohtana on se, että lähdekoodin virheitä ei pystytä havaitsemaan ellei kyseisiä rivejä testata 
vähintään yhdellä testillä~\cite{MNDT09}. Testikattavuuden ja laadun välistä yhteyttä on tutkittu yllättävän vähän, 
varsinkaan laadullisista näkökulmista. Testikattavuutta tulee ohjata komponenttien tärkeysjärjestyksen pohjalta. 
Olennaisesti kriittisempiä osia pitää painottaa testeissä, unohtamatta siltikään pienemmissä osissa olevia 
komponentteja.

    Ongelmana on se, että vakavimmat virheet voidaan havaita jo pienellä testikattavuudella. Vaikka jokin yksittäinen 
rivi lähdekoodista on katettu testeillä, ei se takaa sitä, että tämä testi pystyy havaitsemaan kyseisen rivin 
mahdollisesti aiheuttamia virheitä. On kohtuullista odottaa, että suurempi testikattavuus lisää todennäköisyyttä, että 
nämä tilanteet tulevat katettua.

    Eri ohjelmistot kehitetään lähtökohtaisesti eri tarkoituksiin, eri kehittäjien ja testaajien toimesta. 
Testikattavuus on tärkeä suhteellistaa näihin olosuhteisiin. Kontekstit ovat harvemmin samoja. Kokeneet kehittäjät 
kirjoittavat laadullisesti parempia testejä, koska kokemuksen karttuminen kasvattaa testikattavuutta ja näin ollen 
vähentää ohjelmiston virhetiheyttä. Inhimillisillä tekijöillä on valtava merkitys ohjelmiston laadullisissa tekijöissä.

    Testikattavuus on käytännöllinen ja järkevä keino mitata ja varmistaa ohjelmiston laatua~\cite{MNDT09}. 
Valitettavasti täydellisen testikattavuuden saavuttaminen ei ole todennäköisesti järkevää, sillä sen lopullinen 
hyödyllisyys näyttää olevan negatiivinen ja samalla suurempien testikattavuuksien saavuttaminen haasteellista.\newline

\noindent Testikattavuudesta on tehtävissä neljä johtopäätöstä:
    
\begin{enumerate}

    \item Ohjelmiston hyväksymäkriteereihin tulee kuulua kohtuullinen testikattavuus.
          
    \item Täydellinen testikattavuus ei yleensä ole tehokkuuden kannalta järkevää. Testikattavuuden saavuttaminen kasvaa 
          eksponentiaalisesti mitä suurempiin testikattavuuksiin tähdätään. Samalla virheiden määrä näyttää laskevan 
          vain lineaarisesti.
          
    \item Täydellinen testikattavuus vaatii haasteellista poikkeustenkäsittelyä lähde\-koodissa.
    
    \item Tehokkuuden kannalta optimaalisin testikattavuus vaihtelee suuntaan tai toiseen ohjelmistosta riippuen.

\end{enumerate}

\subsubsection{Testikattavuuden pätevyyteen vaikuttavia tekijöitä}

Testikattavuuden pätevyyteen vaikuttaa samat piirteet, jotka vaikuttivat koodikirnun ja verkkoanalyysin pätevyyteen. 
Empiiristä tutkimuksista on vaikea tehdä yleisiä päätelmiä niiden kontekstisidonnaisen luonteen takia. Tutkimuksen 
pätevyyttä tukevoittaa se, että Mockuksen ym. tapaustutkimuksessa tutkittiin kahta täysin erilaista 
ohjelmistoa~\cite{MNDT09}. Ohjelmistojen takana oli eri organisaatio, sovellusala, ohjelmointikieli ja koko. Samalla 
kehittäjätiimien ja käyttäjäkuntien koko oli eri. Voidaan olettaa, että testikattavuus soveltuu muihin ohjelmistoihin.

\subsection{Mutaatiotestaus}

Testikattavuuden ongelmaksi muodostuu se, että se ei arvioi testien laatua. Se tarkastelee vain mitä osia ohjelmiston 
lähdekoodista on katettu testitapauksilla. Useinkaan pelkkä testikattavuus ei arvioi ohjelmiston laatua halutulla 
tasolla.

    Testien laadun arvioimiseen on ehdotettu mutaatiotestausta~\cite{YH11}. Mutaatiotestaus arvioi testien sopivuutta 
niiden kattamaan lähdekoodiin simuloimalla yleisempiä virheitä joita kehittäjät tekevät. Ohjelmiston lähdekoodia kuten 
sen sisältämiä ehtoja harkitusti muuttamalla pystyy mutaatiotestaus jäljittelemään kaikki mahdolliset testitapaukset. 
Mutaatiotestaus ei pelkästään arvioi testien laadukkuutta vaan sen on havaittu parantavan suoraan testien 
laatua~\cite{YH11}. Sillä voidaan priorisoida testien kohteita sekä minimoimaan niitä testaavaa koodia säilyttäen niiden 
alkuperäisen kattavuuden.

    Yksinkertaisten syntaksimuutosten avulla mutaatiotestaus pystyy muodostamaan virheellisiä mutanttiversioita 
ohjelmistosta, joiden ei pitäisi mennä testeistä läpi. Jokainen mutanttiversio on syntaksiltaan toista hieman erilainen. 
Valitut mutantit ajetaan ohjelmiston testitapausten läpi ja samalla tutkitaan havaitsevatko testit mutanttien väärän 
toiminnallisuuden.

    Ideana on, että mitä suuremman määrän mutanttien aiheuttamia virheitä testitapaukset löytävät, sitä parempia ne ovat 
laadullisesti~\cite{YH11}. Mutaatiotestaus on monikäyttöinen metriikka ohjelmiston testitapausten arvioimiseen. Sitä 
voidaan käyttää yksikkö-, integraatio- ja määritelmätason testeihin. Mutaatiotestaus soveltuu eri käyttötapauksiin 
perusohjelmistojen lisäksi kuten tietokoneympäristöjen, web-sovellusten, verkkojen ja turvallisuuden arvioimiseen.

    Mutaatiotestauksen ongelmaksi muodostuu mahdollisten mutanttien valtava määrä. Jokaiselle syntaktiselle muutokselle 
ei ole järkevää saati mahdollista muodostaa mutanttia. Olio-ohjelmointi lisää haastavuutta sillä se tuo paljon korkean 
tason ominaisuuksia kieleen ja syntaksiin. Mutaatiotestaukseen on tärkeää valita vain oleellisimmat tapaukset, mutta 
tämä on erittäin haastava ongelma. Syntaksisesti erilaiset mutantit voivat olla toiminnaltaan täysin samanlaisia. Tätä 
ei voida kuitenkaan automaattisesti päätellä sillä ohjelmien yhtäläisyys on ratkeamaton ongelma. Mutaatiotestauksen 
tulee valita järkevästi vain osa mutanteista ja suorittaa nämä tehokkaasti. Ongelmaan on ehdotettu useita eri 
ratkaisuja~\cite{YH11}.

    Ohjelmoijat ovat usein täysin päteviä tuottamaan koodia joka on vähintään lähellä tarkoitettua toiminnallisuutta. 
Virheet lähdekoodissa ovat usein pieniä. On syytä olettaa, että mutaatiotestauksen tarvitsee keskittyä vain lähimpiin 
syntaksivirheisiin. Yleisimmät mutaatio-operaattorit muuttavat, lisäävät sekä poistavat muuttujia ja ehtolauseita. Näitä 
ovat esimerkiksi \emph{ja} -operaattoreiden muuttaminen \emph{tai} -operaatioiksi.

Vaikka mutaatiotestausta on tutkittu erittäin kattavasti, on sen käytäntöön soveltamisessa vielä haasteita. 
Mutaatiotestausta voitaisiin käyttää hyödyksi kattavammin testitapausten ja testikehysten parantamisessa~\cite{YH11}. 
Ennen kaikkea mutaatiotestaus voi tarjota käytännöllisen keinon ohjelmiston laadun parantamisessa.

\section{Kehittäjien käytänteet}

Ohjelmiston koodin tuottajana on ihminen: kehittäjien käytänteillä ja ohjelmiston kehitysprosesseilla on suuri 
laadullinen merkitys. Avainkysymykseksi nousee niiden käytänteiden paikallistaminen, joilla on ratkaiseva yhteys 
ohjelmiston laatuun.

    Ennakkosuunniteluun pohjautuvien menetelmien, kuten vesiputousmallin, rinnalla on noussut uusia ketterän kehityksen 
prosesseja. Ketterien kehitysprosessien hyöty on merkittävä laadullinen tekijä~\cite{SS10}.

    Ketterän kehityksen manifesti (agile manifesto) on muodostunut ketterän kehityksen tavoitteiden 
ympärille~\cite{BBB01}. Se painottaa yksilöitä ja yksilöiden vuorovaikutusta, toimivan ohjelmiston merkitystä, asiakkaan 
merkitystä kehitysprosessin kriittisenä osana sekä muutoksiin sopeutuvaa kehitystä. Näiden periaatteiden takaamiseksi 
ketterän kehityksen prosesseille on muodostunut useita käytänteitä. Näillä kehittäjät pystyvät hallinnoimaan ja 
varmistamaan laadullisesti kehitystyötä. Ketterä kehitys huomioi nimenomaan asiakkaan kehitysprosessin tärkeänä osana.

    Asiakkaan tarpeet tulee kartoittaa ja taata koko kehitysjakson aikana. Lopulta tuotettavan tuotteen pitää tuoda 
arvoa asiakkaalle. Ohjelmiston vaatimuksia on vaikea määrittää kattavasti heti alusta lähtien, siksi ketterässä 
prosessissa painotetaan muutoksien hyväksymistä. Ohjelmiston kehitys saattaa olla pitkäaikainen prosessi, tilanteet ja 
käyttötarkoitukset muuttuvat prosessin aikana. Asiakas saattaa havaita ohjelmiston kannalta tärkeitä asioita myöhään 
kehityksessä.

\subsection{Ketterä kehitys}

Ketterän kehityksen idea on mahdollistaa muutokset kehitystyössä. Kehitystyötä tehdään iteratiivisesti pienissä 
palasissa ja samanaikaisesti painotetaan menetelmiä, jotka kasvattavat ohjelmiston hallintaa ja laatua. Laadun hallinta 
ja valvonta tulee jakaa koko kehityksen ajalle. Tarkoituksena on vähentää muutoksista johtuvia kustannuksia 
kehitystyössä~\cite{HC01}. Jokaisen iteraation jälkeen tulee asiakkaalle toimittaa osa ohjelmiston 
toiminnallisuudesta. Tällöin asiakas voi havaita jo aikaisessa vaiheessa mahdolliset ongelmat tavoitteidensa ja 
toivomusten osalta sekä pyrkiä selventämään niitä kehittäjille. Ketterän kehityksen on todettu vähentävän kehitykseen 
kuluvaa aikaa pitkällä tähtäimellä~\cite{HC01}.

    Ketterässä kehityksessä laadun valvonta ei ole pelkästään yhden henkilön tehtävä. Jokainen kehitystyöhön osallistuva 
henkilö tekee sitä jatkuvasti omalta osaltaan. Henkilöille pitää luoda ilmapiiri ja ympäristö, jossa tämä on 
mahdollista. Kehitystiimin ja asiakkaan välinen luottamus on tärkeää. Jatkuva tiedonvälitys ja keskustelu on olennainen 
osa tämän saavuttamista. Asiakas on jatkuvasti kehityksessä mukana arvioiden sovellusta. Samanaikaisesti hän varmistaa 
tuotteen toimivuutta käyttäjien kannalta. Ohjelmiston kehittäjät kokevat asiakkaan erittäin hyödyllisenä 
kehitysprosessissa~\cite{DD08}.

    Hyvien käytänteiden ja laadullisesti järkevien ratkaisujen seuraaminen parantaa ohjelmiston suunnittelua ja laatua. 
Mahdollisia ongelmia tulee katselmoida mahdollisimman usein ja tiimin toimintoja kehittää näiden ongelmien osalta. 
Ketterän kehityksen prosessit eivät kuitenkaan kerro yksiselitteisesti miten kehitys pitää toteuttaa. Ne luovat 
kehyksen, jonka pohjalta kukin ohjelmistokehittäjä ja tiimi rakentaa omaan tarkoitukseen toimivan 
kokonaisuuden~\cite{Kn07}.

    Nykyään eniten käytössä olevat ketterän kehityksen prosessit ovat Scrum ja XP~\cite{SS10}. Suurin osa tutkimuksista on 
suoritettu XP:n käytänteistä~\cite{DD08}. Scrum tarjoaa ketterälle kehitykselle toimivaksi osoitetun kehyksen ja XP 
lukuisia ketterään kehitykseen soveltuvia ohjelmistokehityksen käytäntöjä. Scrum keskittyy lähinnä kehityksen 
hallinnolliseen puoleen: miten ohjelmistokehitys tulee suunnitella, hallinnoida ja ajoittaa. Tästä syystä Scrum ja XP 
tukevat toisiaan~\cite{Kn07}.

    Scrumissa yksittäisiä iteraatioita kutsutaan pyrähdyksiksi, eli sprinteiksi. Jokainen sprintti muodostuu yhdessä 
asiakkaan kanssa valituista ja priorisoiduista ominaisuuksista tai parannuksista, joita kehittäjien tulee sen aikana 
pyrkiä toteuttamaan. Itse toteutusta tukee useita XP:n esittämiä käytäntöjä, muun muassa testilähtöinen kehitys, 
pariohjelmointi ja suunnittelupeli. Testilähtöisessä kehityksessä ohjelmiston kehityksessä testit kirjoitetaan ennen 
niiden toteuttavaa toiminnallisuutta. Pariohjelmoinnissa parannetaan kehittäjien taitoja ratkomalla ongelmia yhdessä 
työskentelyparin kanssa ja suunnittelupelissä yritetään arvioida kehitykseen kuluvaa aikaa ja samalla havaita ja pohtia 
mahdollisia ongelmia. XP:n käytännöt on nykyään sulautunut osaksi Scrumia~\cite{Kn07}.

    Ketterää kehitystä on myös kritisoitu~\cite{DD08}. Huonosti toteutettu ketterä kehitys voi viedä huomion ohjelmiston 
kokonaissuunnittelusta. Näin ollen ohjelmiston suunnitteluratkaisut saattavat jäädä pirstaleisiksi. Ketterä kehitys 
sisältää paljon ideologiaa ja tutkimukset ovat suurelta osin vain empiirisiä. Ketterän kehityksen tuoman hyödyn 
mittaaminen on siksi haasteellista. Yhdeksi kysymykseksi on nostettu ketterän kehitysprosessien soveltaminen isoissa 
yrityksissä, koska käytänteiden soveltaminen on usein helpompaa pienemmissä kehitystiimeissä. Valtaosa kehittäjistä 
jotka ovat kokeilleet ketterää kehitystä haluavat jatkaa sen käyttämistä.

    Useissa tutkimuksissa on pohdittu ristiriitoja kokeellisten ja empiiristen tutkimusten välillä~\cite{DD08, SS10}. 
Kokeelliset tutkimukset ajoittuvat yleensä lyhyelle aikajaksolle kun taas empiiriset tutkimukset arvioivat ajallisesti 
pidempää kehitysprosessia. Siksi kokeelliset tutkimukset päätyvät yleensä maltillisempiin tuloksiin ketterän kehityksen 
hyödyistä. Empiiriset tutkimukset näkevät ketterien prosessien vahvan hyödyn, mutta ongelmaksi muodostuu tulosten 
yleistäminen. Hyöty voidaan yleensä nähdä vain parannuksena ulkoiseen laatuun~\cite{SS10}.

\subsection{Testilähtöinen kehitys}

Testilähtöinen kehitys koostuu lähdekoodin kirjoittamisesta testilähtöisesti ja koodin jatkuvasta parantamisesta eli 
refaktoroinnista. Refaktoroinnissa tehdään pieniä muutoksia ohjelmiston koodiin muuttamatta sen ulkopuolista 
toiminnallisuutta. Testilähtöisessä kehityksessä testit kirjoitetaan ennen toiminnallisuuden ohjelmoimista. Tämän on 
tarkoitus saada kehittäjä suunnittelemaan ja miettimään uusia toiminnallisuuksia ja niiden ongelmia ennen logiikan 
toteuttamista. Jatkuvalla refaktoroinnilla pyritään rakentamaan toiminnallisuudet paremmiksi, kehittämällä jatkuvasti 
ohjelmiston lähdekoodia.

    Hyväksymätestien lisäksi, joita käytetään ohjelmiston vaatimusten määrit\-telemiseen, testilähtöinen kehitys ja 
refaktorointi parantavat yleisesti ohjelmiston laatua. Suurin osa kokeista ja tapaustutkimuksista on havainnut laajoja 
laadullisia parannuksia ohjelmistojen ulkoiseen laatuun~\cite{SS10}. Julkaisun jälkeiset virheet vähenivät 
merkittävästi. Tapaustutkimukset osoittivat suurempaa parannusta kuin kokeet. Kokeiden osalta heikompi parannus voidaan 
selittää valvotun ympäristön ja ajallisten rajoitusten seurauksena. Testilähtöisen kehityksen vaikeus nähdään osasyyksi 
heikompiin tuloksiin~\cite{PC11}. Testien kirjoittaminen ennen toiminnallisuutta vaatii harjoittelua, jota jälkeen 
kirjoitettujen testien osalta ei vaadita. Siksi testilähtöisen kehityksen hyödyn vaikutukset todennäköisesti ilmentyvät 
vasta myöhemmin. Vain muutama koe ei havainnut testilähtöisellä kehityksellä olevan merkittävää vaikutusta ohjelmiston 
ulkoiseen laatuun~\cite{SS10}.

    Sisäinen laatu kasvoi testilähtöisen kehityksen ansiosta merkittävissä määrin~\cite{SS10}. Lähdekoodin 
uudelleenkäytettävyys ja vaivannäkö testaamista varten parani. Osa tutkimuksista osoitti lopullisen ohjelmiston 
kehitysajan kasvavan, mutta samalla osa tutkimuksista huomasi kehityksen kokonaiskustannusten vähenevän. Tuottavuuden 
kannalta tutkimukset osoittivat ristiriitaisia tuloksia: osassa tuottavuus kasvoi, osassa tuottavuudelle ei tapahtunut 
merkittäviä muutoksia, osassa tuottavuus taas laski.

\subsection{Pariohjelmointi}

Pariohjelmointi on erittäin sosiaalinen ja yhteistyöhön perustuva toimintamalli. Se keskittyy kehittäjien yksilöllisiin 
taitoihin, kokemukseen, ominaispiirteisiin ja persoonallisuuteen. Pariohjelmoinnin tarkoitus on jatkuva suunnittelu ja 
koodikatselmus kahden kehittäjän kesken. Kehittäjät kirjoittavat yhdessä ohjelmiston toiminnallisuutta. Tämä vähentää 
virheiden määrää ja parantaa ohjelmiston suunnittelua ja laatua~\cite{SS10}. Pariohjelmoinnin havaittiin lisäävän hyvien 
ohjelmointitapojen käyttöä~\cite{DD08}.

    Pariohjelmoinnin on havaittu olevan yksi merkittävimmistä laadullista tekijöistä käytännön näkökulmasta~\cite{SS10}. 
Koodin suunnittelu ja laatu kasvoi huomattavasti. Monimutkaisiin ja vaativiin ongelmiin pariohjelmointi tuotti 
olennaisesti parempaa koodia kuin ohjelmointi yksin. Pariohjelmoinnin todettiin parantavan tiimityöskentelyn laatua, 
tiedon ja taitojen parempaa siirtymistä yksilöltä toiselle~\cite{DD08, SS10}, tehokkaampia ja paremmin suunniteltuja 
algoritmeja, moraalin kasvua ja luottavaisempia kehittäjiä~\cite{SS10}. Pariohjelmointi parantaa tuotetun lähdekoodin 
laatua~\cite{DD08}.

    Pariohjelmoinnin todettiin vaativan enemmän vaivannäköä kehittäjiltä ja siksi pariohjelmointi kasvatti kehitystyön 
kustannuksia~\cite{SS10}. Tehokkuus väheni lievästi ja kehitystyön aikataulutus vaikeutui ja samalla kehitystiimeissä 
havaittiin persoonallisuus kitkoja. Tutkimukset havaitsivat tiettyjen taito, tieto ja kokemuspiirteiden sopivan paremmin 
pariohjelmointiin. Erityisesti persoonallisuuspiirteillä havaittiin suuri merkitys: avomieliset ja vastuulliset yksilöt 
sekä monipuoliset persoonallisuudet ja temperamentit soveltuvat pariohjelmointiin paremmin. Osa kehittäjistä pitää 
pariohjelmointia turhauttavana~\cite{DD08}.

\section{Metriikat käytänteiden tukena}

Laadun varmistamista rajaa ohjelmistokehityksessä henkilöt, aika ja raha~\cite{BBM96, ZN08}. Kehittäjät kohtaavat usein 
tiukkoja määräaikoja ja rajallisia henkilöresursseja laadun takaamiseen. Johtajat käyttävät käytännössä pelkästään 
omakohtaisia kokemuksiaan resurssien tehokkaaseen jakamiseen. Yleisenä totuutena pidetään, että monimutkaisiin 
komponentteihin on syytä varata enemmän aikaa että rahaa~\cite{BBM96, ZN08}. Tällä turvataan se, että komponenttien 
testaus ja tarkastus ohjataan haastavimpiin osa-alueisiin. Johtajilla ei kuitenkaan ole aina tarvittavaa kokemusta tai 
tietoa, joiden pohjalta he voisivat tehdä päätöksiä järkevästi. Siitä johtuen päätökset tehdään usein johtajien 
odotusten mukaan ja tällöin he joutuvat arvioimaan laatua puutteellisin tiedoin. Kriittiseksi osaksi muodostuu johtajien 
taito. On todennäköistä, että laadullisen arvioinnin tehokkuus ja vaatimustaso kärsivät tästä.

\subsection{Kehittäjien tuki ja vastuun antaminen}

Beck ym. puolustavat ketterän kehityksen manifestissa ketterän kehityksen itse organisoituvaa luonnetta~\cite{BBB01}. 
Kun kehittäjille annetaan tarpeeksi tukea, ottavat he itse vastuun ohjelmiston laadullisista puolista. Jatkuva hyvien 
käytänteiden ja suunnitteluperiaatteiden seuraaminen johtaa lopulta ohjelmiston laadun kasvuun~\cite{SS10}. Tiimien 
tulee arvioida näiden onnistumista tarpeeksi usein, jotta mahdollisiin ongelmiin voidaan puuttua ja tiimin käytänteitä 
hienosäätää. Vastuun siirtäminen johtajilta kehittäjille nopeuttaa virheiden löytämistä ja niihin 
puuttumista~\cite{DD08}. Ohjelmiston lähdekoodin yhteisvastuu kasvatti tiimin jäsenten moraalia.

    Tiimien ei tule luistaa ohjelmiston sisäisen laadun varmistamisesta~\cite{Kn07}. Se on perustavanlaatuisesti 
kehittäjien vastuu. Kehitys täytyy tehdä laadukkaasti vaikka se vie enemmän aikaa kun alun perin suunniteltiin. Muuten 
kehitettyjä ominaisuuksia ei voida hyväksyä osaksi ohjelmistoa. Tiimien täytyy löytää itselleen optimaaliset 
työskentelytavat ja sovittaa työvauhti sopivaksi kehityksen kannalta. On järkevämpää toteuttaa vähemmän kerralla, mutta 
toteuttaa se laadukkaasti. Suunnitelmien tiukka noudattaminen ei edistä ohjelmistojen tarkoitusta asiakkaan tarpeiden ja 
toiveiden toteuttamisessa~\cite{HC01}.

    Suunnittelupeli ja sprintin suunnittelu kattavat toiminnan, jota voitaisiin verrata suoraan laadullisten
määritelmien kehykseksi. Ne muodostavat raamit laadukkaalle kehitykselle. Testilähtöinen kehitys, pariohjelmointi ja 
jatkuva integraatio taas paneutuvat laadullisen toteutuksen puoliin~\cite{SS10}. Ne tukevat kehittäjää toteuttamaan 
laadukasta ohjelmistoa. Toimiva koodi on ketterän kehityksen tärkeimpiä tavoitteita~\cite{HC01}. Suora kommunikaatio 
kehittäjien keskuudessa ja ennen kaikkea asiakkaan kanssa tuottaa paremman tuloksen kuin yksilökeskeinen ympäristö.

    Moni XP:n käytännöistä yhdessä, kuten suunnittelupeli, pariohjelmointi ja testilähtöinen kehitys parantavat 
ohjelmiston laatua~\cite{SS10}. Suunnittelupelin havaittiin parantavan kehityksen työmäärän ajallista estimointia. 
Käytänteiden seuraamisesta havaittiin refaktoroinnin ja tuottavuuden kasvu. XP -käytänteiden havaittiin toimivan 
paremmin nimenomaan pienissä kehittäjätiimeissä.

\subsection{Hyvät ohjelmointikäytänteet}

Lopulta kehittäjät tekevät laadukkaan ohjelmiston. Ulkoinen ja sisäinen laatu lähtee siitä, että ohjelmisto 
suunnitellaan, toteutetaan ja testataan käyttäen hyväksi todettuja ohjelmointitapoja ja malleja. Nämä vaihtelevat 
myötäilen jokaisen ohjelmointikielen ajatusmalleja. Jokaisella kehittäjällä on oma mielipide asiasta.

    Hyvän koodin laatuattribuuteiksi voidaan luotella muun muassa lähdekoodin kapselointi (algoritmien yksityiskohtien 
piilottaminen), koheesio (komponenttien yksi vastuu), riippuvuuksien vähäisyys, toistettavuus, testattavuus ja 
selkeys~\cite{Sc08}. Jokainen näistä laatuattribuuteista pureutuu ohjelmointikäytänteisiin. Hyvillä käytänteillä 
minimoidaan sortuminen virheisiin ja helpotetaan ohjelmiston ylläpidettävyyttä.

    Vaikka ohjelmisto toteutettaisiin pala kerraltaan, hyvät suunnittelu- ja toteutusmallit nousevat lopulta tärkeään 
rooliin kokonaisuuden kannalta. Jo vuonna 1976 päädyttiin siihen, että rakenteellisesti järkevät ohjelmistot helpottavat 
ohjelmiston ylläpidettävyyttä ja tuottavat laadullisesti paremman ohjelmiston~\cite{LK76}.

    Huonot ratkaisut johtavat ohjelmiston kannalta tekniseen velkaan~\cite{FFS12}. Fowler määrittelee lukuisia 
koodihajuja, joita voidaan pitää ohjelmiston huonon sisäisen laadun ja ylläpidettävyyden merkkinä. Koodihajuja ovat muun 
muassa suuret komponentit ja toistuva koodi. Suuret komponentit ovat muita virheherkempiä ja huomattavasti vaikeampia 
ylläpitää. Varsinkin toistuvaa koodia pidetään huonona ratkaisuna jota pitää välttää~\cite{FFS12}. Toisaalta 
koodihajujen ja heikomman ylläpidettävyyden yhteys on jokseenkin kyseenalainen~\cite{SYAMD12}. Koodihajut eivät 
välttämättä lisää kehityksen työmäärää.

\subsection{Kehityksen laadullinen varmistaminen}

Tutkimukset koodikirnusta, verkkoanalyysista ja testikattavuudesta ohjelmiston laadullisina metriikoina toivat esille 
inhimillisen tekijän laadun takaamisessa~\cite{NB05, ZN08, MNDT09}. Kehittäjän tulee aktiivisesti itse vaikuttaa 
ohjelmiston laatuun. Tutkimusten mukaan ketterä kehitys on oivallinen käytäntö ohjelmiston laadun 
varmistamisessa~\cite{SS10}.

    Yhtenä ratkaisuna esitetään koodikirnun ja ohjelmiston riippuvuuksien käyttämistä laatua mittaavina 
metriikoina~\cite{NB05, NB07}. Testien kirjoittaminen tulee ohjata näiden metriikoiden ilmaisemiin virheherkkiin 
komponentteihin~\cite{MNDT09}. Voidaan nähdä, että testilähtöinen kehitys tukee näiden metriikoiden tavoitteita 
osuvasti. Koodikirnussa painotetaan erikseen hyviä versionhallinnan käytäntöjä~\cite{NB05}. Ohjelmistoon tehdyt 
muutokset tulee rekisteröidä pienissä palasissa versionhallintaan mahdollisimman aikaisin ja usein. Tällä säästetään 
kallisarvoista kehitystyön historiaa ja mahdollistetaan ongelmatapauksissa paluu vanhoihin toimiviin koodiversioihin.

    Verkkoanalyysillä~\cite{ZN08} voidaan ohjata sekä testauksen, että suunnittelun varoja sinne missä ne ovat 
tärkeimpiä~\cite{NB07, MNDT09}. Mutaatiotestauksella pystytään arvioimaan testien laadukkuutta ja priorisoimaan niitä 
lähdekoodin kohteita joita tulee testata kattavammin~\cite{YH11}. Samalla vähennetään inhimillisten, johtajien tai 
muiden kehitystiimin jäsenten tietotaitoon liittyviä riskejä ja parannetaan näin ohjelmiston laatua.

    Vaikka metriikoita on tutkittu jo pitkään, niiden täydellistä potentiaalia ei ole vieläkään valjastettu 
käyttöön~\cite{YH11}. Metriikat ovat perimmiltään vielä osittain tieteellisiä eikä niitä arvioivia kehittyneitä työkaluja 
ole helposti saatavilla. Suurin hyöty niistä saadaan vasta kun ne saadaan jokaisen kehittäjän käsiin.

\section{Yhteenveto}

Kehitysvaiheessa olevan ohjelmiston laadun varmistaminen on hankalaa\\~\cite{BBM96, NB05, NB07, ZN08, MNDT09}. 
Automaattisesti analysoitavat metriikat tarjoavat yhden keinon kohdentaa resursseja laadun takaamiseksi. CK-metriikat 
keskittyvät olio-ohjelmoinnin piirteistä johtuvien vikaherkkyyksien havaitsemiseen~\cite{CK94, BBM96}. Suhteellista 
koodikirnua esitetään järjestelmän virhetiheyden ennakoimiseen~\cite{NB05}. Koodikirnu mittaa ja ilmaisee määrällisesti 
ohjelmiston komponentteihin kohdistuvia muutoksia tietyn ajanjakson aikana. Komponentit jotka muuttuvat paljon ovat 
tutkimuksen mukaan muita herkempiä virheille.

    Komponenttien riippuvuusverkoille on esitetty verkkoanalyysin suorittamista~\cite{ZN08}. Verkkoanalyysillä voidaan 
paikallistaa ohjelmiston kriittiset komponentit. Keskeisessä roolissa olevat komponentit sekä yksittäiset komponentit, 
joilla on suuri määrä keskinäisiä riippuvuuksia, ovat yleisesti herkempiä virheille.

    Testien laadullista arviointia on tutkittu keinona havaita virheherkkiä komponentteja ohjelmistosta~\cite{MNDT09}. 
Testien analysoimisessa tulee keskittyä nimenomaan niiden kykyyn havaita mahdollisia virheitä ohjelmistosta. Taustalla 
on olettamus, että jos jokin yksittäinen looginen ehto tai polku ei ole katettu vähintään yhdellä testillä, ei sen 
mahdollisesti sisältämiä virheitä pystytä havaitsemaan. Voidaan olettaa, että suurempi testikattavuus löytää 
todennäköisesti enemmän virheitä ja takaa paremman laadun. Mutaatiotestauksella voidaan arvioida ohjelmiston 
testien laatua~\cite{YH11}. Alkuperäisen ohjelmiston lähdekoodin syntaksia muuttamalla pystytään arvioimaan testien 
tehokkuutta havaita mahdollisia virheitä ohjelmiston lähdekoodissa.

    Ohjelmiston koodin kehittäjänä on lopulta ihminen. Laadun takeeksi ei voida luetella pelkästään mekaanisia 
laatua arvioivia metriikoita. Kehittäjän käytänteillä on suuri laadullinen merkitys ohjelmiston kaikissa 
kehitysvaiheissa, joten ohjelmistotuotantomenetelmät nousevat suureen rooliin. Niiden tulee ohjata laadukasta kehitystä. 
Lopulta kehittäjät tekevät laadukkaan ohjelmiston. Ulkoinen ja sisäinen laatu lähtee siitä, että ohjelmisto 
suunnitellaan, toteutetaan ja testataan käyttäen hyväksi todettuja ohjelmointitapoja ja malleja.

    Raskaaseen ennakkosuunniteluun pohjautuvien tuotantomenetelmien, kuten vesiputousmallin, rinnalla on noussut uusia 
ketterän kehityksen prosesseja. Ne painottavat yksilöitä ja yksilöiden vuorovaikutusta, toimivan ohjelmiston merkitystä, 
asiakkaan merkitystä kehitysprosessin kriittisenä osana ja muutoksiin sopeutuvaa kehitystä~\cite{BBB01}. Useat 
empiiriset tutkimukset tukevat ketterien kehitysprosessien hyötyä merkittävänä laadullisina vaikuttajana~\cite{SS10}. 

\newpage

% --- Back matter ---

\bibliographystyle{babalpha-lf}
\bibliography{../lahteet}

\end{document}
